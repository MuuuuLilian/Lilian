#include <Wire.h>
#include <VL53L1X.h>

// The number of sensors in your system.
const uint8_t sensorCount = 2;
int sens_val[] = {0,0};
#define magnet_input 11
#define relaise_1 8
#define relaise_2 9
#define relaise_3 10


#include <WiFiS3.h>
#include <WiFiUdp.h>
#include <OSCMessage.h>

// WiFi Setup
const char* ssid = "EasyBox-640692";
const char* password = "ZiDTuMtLdMMXB5HX";
// OSC destination
IPAddress outIp(192, 168, 2, 109);
unsigned int outPort1 = 8070;
WiFiUDP Udp;
unsigned long lastSend = 0;
const unsigned long sendInterval = 1000;
int valueToSend = 0; 


// The Arduino pin connected to the XSHUT pin of each sensor.
const uint8_t xshutPins[sensorCount] = { 13, 12 };

VL53L1X sensors[sensorCount];

void setup()
{
  pinMode(magnet_input,INPUT_PULLUP);  
  pinMode(relaise_1, OUTPUT);
  pinMode(relaise_2, OUTPUT);
  pinMode(relaise_3, OUTPUT);

  digitalWrite(relaise_1, HIGH); // AUS
  digitalWrite(relaise_2, HIGH); // AUS
  digitalWrite(relaise_3, HIGH); // AUS -> wichtig!

 while (WiFi.begin(ssid, password) != WL_CONNECTED) {
 delay(1000);
 }
 Udp.begin(outPort1); 
 delay(1000);

  while (!Serial) {}
  //Serial.begin(115200);
  Wire.begin();
  Wire.setClock(100000); // use 400 kHz I2C

  // Disable/reset all sensors by driving their XSHUT pins low.
  for (uint8_t i = 0; i < sensorCount; i++)
  {
    pinMode(xshutPins[i], OUTPUT);
    digitalWrite(xshutPins[i], LOW);
  }

  // Enable, initialize, and start each sensor, one by one.
  for (uint8_t i = 0; i < sensorCount; i++)
  {
    // Stop driving this sensor's XSHUT low. This should allow the carrier
    // board to pull it high. (We do NOT want to drive XSHUT high since it is
    // not level shifted.) Then wait a bit for the sensor to start up.
    pinMode(xshutPins[i], INPUT);
    delay(10);

    sensors[i].setTimeout(500); //Timeout ist Wichtig.. Ihr hattet hier vorher 500ms und ich habe es nun auf 100 geändert, was dazu führt dass es stabiler läuft. 
    if (!sensors[i].init())
    {
      //Serial.print("Failed to detect and initialize sensor ");
      //Serial.println(i);
      while (1);
    }

    // Each sensor must have its address changed to a unique value other than
    // the default of 0x29 (except for the last one, which could be left at
    // the default). To make it simple, we'll just count up from 0x2A.
    sensors[i].setAddress(0x2A + i);

    sensors[i].setDistanceMode(VL53L1X::Short);
    sensors[i].setMeasurementTimingBudget(20000);
    sensors[i].startContinuous(50);
  }
}

bool magnet_last_state = true;  // Initial auf HIGH, weil INPUT_PULLUP
bool relaise_3_state = false;   // Anfangszustand des Relais 3

bool resetSensor(uint8_t index) {
  //Serial.print("Resetting sensor ");
  //Serial.println(index);

  // Sensor per XSHUT ausschalten
  pinMode(xshutPins[index], OUTPUT);
  digitalWrite(xshutPins[index], LOW);
  delay(50);

  // Sensor starten
  pinMode(xshutPins[index], INPUT); // loslassen, damit Pullup vom Breakout greift
  delay(50);

  if (!sensors[index].init()) {
    //Serial.print("Reinit failed for sensor ");
    //Serial.println(index);
    return false;
  }

  sensors[index].setAddress(0x2A + index);
  sensors[index].startContinuous(100);
  //Serial.print("Sensor ");
  //Serial.print(index);
  //Serial.println(" successfully reinitialized.");
  return true;
}

void loop()
{
    unsigned long now = millis(); 
  for (uint8_t i = 0; i < sensorCount; i++)
  {
    sens_val[i] = sensors[i].read();
    //Serial.print(sens_val[i]);
      if (sensors[i].timeoutOccurred()) {
        //Serial.print("Sensor ");
        //Serial.print(i);
        //Serial.println(" TIMEOUT – attempting reinit...");
        resetSensor(i);
      }
    //Serial.print('\t');
  }
  //Serial.println();

  // Steuerung für Relais 1
  if (sens_val[0] <= 90){
    digitalWrite(relaise_1, HIGH);
  } else {
    digitalWrite(relaise_1, LOW);
  }

  // Steuerung für Relais 2
  if (sens_val[1] <= 470){
    digitalWrite(relaise_2, HIGH);
  } else {
    digitalWrite(relaise_2, LOW);
  }

  // Flankenerkennung für Magnet
  bool magnet_current_state = digitalRead(magnet_input);
  if (!magnet_last_state && magnet_current_state) {  // LOW → HIGH Flanke
    relaise_3_state = !relaise_3_state;              // Zustand umschalten
    digitalWrite(relaise_3, relaise_3_state ? LOW : HIGH);
  }
  magnet_last_state = magnet_current_state;

 if (now - lastSend >= sendInterval) {
 lastSend = now;
 // Send OSC message with valueToSend (0 or 1)
 OSCMessage msg("/toggle");
 msg.add(sens_val[0]);
 msg.add(",");
 msg.add(sens_val[1]);
 Udp.beginPacket(outIp, outPort1);
 msg.send(Udp);
 Udp.endPacket();
 msg.empty();
 // Toggle value for next send
 }
}
